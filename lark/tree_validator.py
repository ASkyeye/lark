"""Tree validator based on Lark grammar

Warning: Experimental feature! Use at your own risk.
"""

from .exceptions import GrammarError
from . import UnexpectedToken, Tree, Token

from .tree_matcher import TreeMatcher, is_discarded_terminal

# TODO handle ambiguity by iterating into every possible derivation, using ambiguity='explicit'

class ValidationError(Exception):
    pass

class TreeValidator:
    """Tests whether or not a given tree could be generated by the given parser
    """

    def __init__(self, lark_inst):
        self.ltm = TreeMatcher(lark_inst)

    def _validate_tree(self, tree, rulename=None):
        "rulename used for disambiguating templates"
        try:
            res = self.ltm.match_tree(tree, rulename)
        except GrammarError as e:   # rulename is not in grammar
            raise ValidationError(e)
        except UnexpectedToken as e:    # tree doesn't match any rule
            raise ValidationError(e)

        exp = [sym for sym in res.meta.orig_expansion if not is_discarded_terminal(sym)]
        assert len(res.children) == len(exp)
        for child, symbol in zip(res.children, exp):
            if isinstance(child, Tree):
                self._validate_tree(child, symbol.name)
            else:
                assert isinstance(child, Token)
                if symbol.name != child.type:
                    raise ValidationError(child, symbol)

    def validate(self, tree):
        "Validate tree based on Lark grammar"
        try:
            self._validate_tree(tree)
            return True
        except ValidationError:
            return False
